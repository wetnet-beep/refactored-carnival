<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gate Upgrader 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #0a0a1a;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            height: 30px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid #ff0000;
            border-radius: 15px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff8800);
            width: 100%;
            transition: width 0.3s;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00aaff;
        }
        
        .wave-info {
            position: absolute;
            top: 70px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
        }
        
        .buff-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            max-width: 500px;
            flex-wrap: wrap;
        }
        
        .buff-icon {
            width: 60px;
            height: 60px;
            background: rgba(0, 100, 255, 0.5);
            border: 2px solid #00aaff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            pointer-events: auto;
        }
        
        .shop-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            background: linear-gradient(45deg, #ffaa00, #ff5500);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s;
        }
        
        .shop-button:hover {
            transform: scale(1.05);
        }
        
        #cheatInput {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            color: #00ff00;
            display: none;
        }
        
        .gate {
            position: absolute;
            width: 200px;
            height: 300px;
            perspective: 1000px;
        }
        
        .gate-side {
            position: absolute;
            width: 100px;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
            backface-visibility: hidden;
            border: 5px solid;
            border-radius: 10px;
        }
        
        .gate-positive {
            left: 0;
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .gate-negative {
            right: 0;
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .bullet {
            position: absolute;
            width: 10px;
            height: 10px;
            background: yellow;
            border-radius: 50%;
            box-shadow: 0 0 20px yellow;
        }
        
        #gameOverScreen, #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .screen-title {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px currentColor;
        }
        
        .restart-button {
            padding: 20px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #00aaff, #0088ff);
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #shopScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 50, 0.95);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid gold;
            display: none;
            z-index: 50;
            min-width: 500px;
            pointer-events: auto;
        }
        
        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .shop-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .resource {
            display: inline-block;
            margin-left: 20px;
            font-weight: bold;
        }
        
        .coins {
            color: gold;
        }
        
        .gems {
            color: #00ffff;
        }
        
        #closeShop {
            position: absolute;
            top: 10px;
            right: 10px;
            background: red;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
        }
        
        #debugInfo {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
            
            <div class="stats">
                <div>–ú–æ–Ω–µ—Ç—ã: <span id="coins" class="coins">0</span></div>
                <div>–ê–ª–º–∞–∑—ã: <span id="gems" class="gems">0</span></div>
                <div>–£—Ä–æ–Ω: <span id="damage">x1.0</span></div>
                <div>–°–∫–æ—Ä–æ—Å—Ç—å: <span id="speed">x1.0</span></div>
            </div>
            
            <div class="wave-info">
                –í–æ–ª–Ω–∞: <span id="wave">1</span>
                –í—Ä–∞–≥–æ–≤: <span id="enemies">0</span>
            </div>
            
            <div class="buff-display" id="buffDisplay"></div>
            
            <button class="shop-button" onclick="openShop()">–ú–∞–≥–∞–∑–∏–Ω</button>
            
            <input type="text" id="cheatInput" placeholder="–í–≤–µ–¥–∏—Ç–µ —á–∏—Ç-–∫–æ–¥...">
        </div>
        
        <div id="gameOverScreen">
            <div class="screen-title" style="color: red;">–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</div>
            <div style="font-size: 24px; margin-bottom: 20px;">–î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –≤–æ–ª–Ω–∞: <span id="finalWave">1</span></div>
            <button class="restart-button" onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
        
        <div id="victoryScreen">
            <div class="screen-title" style="color: gold;">–ü–û–ë–ï–î–ê!</div>
            <div style="font-size: 24px; margin-bottom: 20px;">–í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ –≤–æ–ª–Ω—ã!</div>
            <button class="restart-button" onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
        
        <div id="shopScreen">
            <button id="closeShop" onclick="closeShop()">X</button>
            <h2 style="text-align: center; margin-bottom: 20px; color: gold;">–ú–ê–ì–ê–ó–ò–ù</h2>
            <div id="shopItems"></div>
        </div>
        
        <div id="debugInfo"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò–ì–†–´ ====================
        const CONFIG = {
            player: {
                speed: 0.2,
                rotationSpeed: 0.003,
                startHealth: 100,
                startCoins: 100,
                startGems: 10
            },
            weapon: {
                baseDamage: 10,
                fireRate: 5, // –≤—ã—Å—Ç—Ä–µ–ª–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
                bulletSpeed: 0.8
            },
            gates: {
                spawnInterval: 10000, // –º—Å
                lifetime: 15000,
                positiveChance: 0.6
            },
            waves: [
                { enemies: 5, spawnRate: 2000, enemyHealth: 30, reward: 10 },
                { enemies: 8, spawnRate: 1800, enemyHealth: 40, reward: 15 },
                { enemies: 12, spawnRate: 1500, enemyHealth: 50, reward: 20 },
                { enemies: 15, spawnRate: 1300, enemyHealth: 60, reward: 25 },
                { enemies: 20, spawnRate: 1000, enemyHealth: 80, reward: 30, boss: true }
            ],
            buffs: {
                positive: [
                    { name: "–£—Ä–æ–Ω+", icon: "‚öîÔ∏è", damage: 1.5, health: 0 },
                    { name: "–°–∫–æ—Ä–æ—Å—Ç—å+", icon: "‚ö°", speed: 1.3, health: 0 },
                    { name: "–ó–¥–æ—Ä–æ–≤—å–µ+", icon: "‚ù§Ô∏è", health: 30, damage: 1 },
                    { name: "–°–∫–æ—Ä–æ—Å—Ç—Ä–µ–ª—å–Ω–æ—Å—Ç—å+", icon: "üéØ", fireRate: 1.4, health: 0 },
                    { name: "–ö—Ä–∏—Ç+", icon: "üí•", damage: 2.0, health: 0 }
                ],
                negative: [
                    { name: "–£—Ä–æ–Ω-", icon: "üíî", damage: 0.5, health: -10 },
                    { name: "–°–∫–æ—Ä–æ—Å—Ç—å-", icon: "üêå", speed: 0.7, health: 0 },
                    { name: "–ó–∞–º–µ–¥–ª–µ–Ω–∏–µ", icon: "‚è≥", speed: 0.5, fireRate: 0.7 },
                    { name: "–°–∞–º —É—Ä–æ–Ω", icon: "‚ò†Ô∏è", selfDamage: 20, damage: 1 }
                ]
            },
            shop: [
                { name: "–ü–∏—Å—Ç–æ–ª–µ—Ç", damage: 10, cost: 0, owned: true },
                { name: "–î—Ä–æ–±–æ–≤–∏–∫", damage: 25, cost: 100, owned: false },
                { name: "–ü—É–ª–µ–º–µ—Ç", damage: 15, fireRate: 10, cost: 200, owned: false },
                { name: "–†–∞–∫–µ—Ç–Ω–∏—Ü–∞", damage: 50, cost: 500, owned: false },
                { name: "–õ–∞–∑–µ—Ä", damage: 30, fireRate: 8, cost: 800, owned: false }
            ]
        };

        // ==================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
        let scene, camera, renderer, controls;
        let player, enemies = [], bullets = [], gates = [];
        let gameTime = 0, currentWave = 0, enemiesRemaining = 0;
        let playerStats = { ...CONFIG.player };
        let weaponStats = { ...CONFIG.weapon };
        let activeBuffs = [];
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let lastShot = 0;
        let gameActive = true;
        let cheatBuffer = "";
        let lastCheatTime = 0;

        // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø THREE.JS ====================
        function init() {
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 100);
            
            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            createPlayer();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∏—Ä–∞
            createWorld();
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è –≤–æ–ª–Ω–∞
            startWave(0);
            
            // –ó–∞–ø—É—Å–∫ —Å–ø–∞–≤–Ω–∞ –≤—Ä–∞—Ç
            setInterval(spawnGate, CONFIG.gates.spawnInterval);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);
            
            // –°—Ç–∞—Ä—Ç –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            updateUI();
        }

        // ==================== –°–û–ó–î–ê–ù–ò–ï –ò–ì–†–û–í–´–• –û–ë–™–ï–ö–¢–û–í ====================
        function createPlayer() {
            // –ú–æ–¥–µ–ª—å –∏–≥—Ä–æ–∫–∞
            const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x00aaff,
                shininess: 100 
            });
            player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);
            
            // –û—Ä—É–∂–∏–µ –∏–≥—Ä–æ–∫–∞
            const gunGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.5);
            const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeometry, gunMaterial);
            gun.position.set(0.3, 0.2, -0.3);
            player.add(gun);
            
            playerStats.health = CONFIG.player.startHealth;
            playerStats.maxHealth = CONFIG.player.startHealth;
            playerStats.coins = CONFIG.player.startCoins;
            playerStats.gems = CONFIG.player.startGems;
        }

        function createWorld() {
            // –ü–æ–ª
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a3a1a,
                side: THREE.DoubleSide 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // –°—Ç–µ–Ω—ã
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x2a2a4a });
            const walls = [];
            
            // –ó–∞–¥–Ω—è—è —Å—Ç–µ–Ω–∞
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(100, 20, 2), wallMaterial);
            backWall.position.set(0, 10, -50);
            backWall.receiveShadow = true;
            scene.add(backWall);
            
            // –ë–æ–∫–æ–≤—ã–µ —Å—Ç–µ–Ω—ã
            for (let i = -1; i <= 1; i += 2) {
                const sideWall = new THREE.Mesh(new THREE.BoxGeometry(2, 20, 100), wallMaterial);
                sideWall.position.set(i * 50, 10, 0);
                sideWall.receiveShadow = true;
                scene.add(sideWall);
            }
            
            // –î–µ–∫–æ—Ä–∞—Ü–∏–∏
            for (let i = 0; i < 20; i++) {
                const boxSize = Math.random() * 3 + 1;
                const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                const boxMaterial = new THREE.MeshPhongMaterial({ 
                    color: Math.random() * 0xffffff 
                });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(
                    Math.random() * 80 - 40,
                    boxSize / 2,
                    Math.random() * 80 - 40
                );
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
            }
        }

        function spawnEnemy() {
            const wave = CONFIG.waves[currentWave];
            const geometry = new THREE.SphereGeometry(1, 8, 8);
            const material = new THREE.MeshPhongMaterial({ 
                color: wave.boss ? 0xff0000 : 0xff8800,
                emissive: wave.boss ? 0x440000 : 0x000000
            });
            const enemy = new THREE.Mesh(geometry, material);
            
            // –ü–æ–∑–∏—Ü–∏—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏
            const angle = Math.random() * Math.PI * 2;
            const distance = 40;
            enemy.position.set(
                Math.cos(angle) * distance,
                1,
                Math.sin(angle) * distance
            );
            
            enemy.castShadow = true;
            enemy.userData = {
                type: 'enemy',
                health: wave.enemyHealth,
                damage: wave.boss ? 20 : 10,
                speed: wave.boss ? 0.08 : 0.05,
                reward: wave.reward,
                isBoss: wave.boss || false
            };
            
            scene.add(enemy);
            enemies.push(enemy);
            enemiesRemaining++;
            updateUI();
        }

        function spawnGate() {
            if (!gameActive || gates.length >= 3) return;
            
            const isPositive = Math.random() < CONFIG.gates.positiveChance;
            const buffs = isPositive ? CONFIG.buffs.positive : CONFIG.buffs.negative;
            const buff = buffs[Math.floor(Math.random() * buffs.length)];
            
            const gateGroup = new THREE.Group();
            
            // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞—è)
            const leftGeometry = new THREE.BoxGeometry(0.5, 3, 0.1);
            const leftMaterial = new THREE.MeshPhongMaterial({ 
                color: isPositive ? 0x00ff00 : 0xff0000,
                emissive: isPositive ? 0x004400 : 0x440000,
                transparent: true,
                opacity: 0.7
            });
            const leftSide = new THREE.Mesh(leftGeometry, leftMaterial);
            leftSide.position.set(-1.5, 1.5, 0);
            leftSide.userData = { buff: buff, isPositive: isPositive };
            gateGroup.add(leftSide);
            
            // –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è)
            const rightGeometry = new THREE.BoxGeometry(0.5, 3, 0.1);
            const rightMaterial = new THREE.MeshPhongMaterial({ 
                color: isPositive ? 0xff0000 : 0x00ff00,
                emissive: isPositive ? 0x440000 : 0x004400,
                transparent: true,
                opacity: 0.7
            });
            const rightSide = new THREE.Mesh(rightGeometry, rightMaterial);
            rightSide.position.set(1.5, 1.5, 0);
            rightSide.userData = { 
                buff: isPositive ? CONFIG.buffs.negative[0] : CONFIG.buffs.positive[0], 
                isPositive: !isPositive 
            };
            gateGroup.add(rightSide);
            
            // –†–∞–º–∞
            const frameGeometry = new THREE.BoxGeometry(3.5, 4, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 1.5, -0.1);
            gateGroup.add(frame);
            
            // –ü–æ–∑–∏—Ü–∏—è
            const angle = Math.random() * Math.PI * 2;
            const distance = 15;
            gateGroup.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
            gateGroup.lookAt(player.position);
            
            gateGroup.userData = {
                type: 'gate',
                lifetime: CONFIG.gates.lifetime,
                spawnTime: Date.now()
            };
            
            scene.add(gateGroup);
            gates.push(gateGroup);
            
            // –£–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è
            setTimeout(() => {
                const index = gates.indexOf(gateGroup);
                if (index > -1) {
                    scene.remove(gateGroup);
                    gates.splice(index, 1);
                }
            }, CONFIG.gates.lifetime);
        }

        // ==================== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ====================
        function startWave(waveIndex) {
            if (waveIndex >= CONFIG.waves.length) {
                victory();
                return;
            }
            
            currentWave = waveIndex;
            const wave = CONFIG.waves[waveIndex];
            enemiesRemaining = 0;
            
            updateUI();
            
            // –°–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤ —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º
            let spawned = 0;
            const spawnInterval = setInterval(() => {
                if (spawned >= wave.enemies || !gameActive) {
                    clearInterval(spawnInterval);
                    return;
                }
                
                spawnEnemy();
                spawned++;
            }, wave.spawnRate);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤–æ–ª–Ω—ã
            const checkWaveComplete = setInterval(() => {
                if (enemiesRemaining <= 0 && spawned >= wave.enemies) {
                    clearInterval(checkWaveComplete);
                    if (gameActive) {
                        setTimeout(() => startWave(waveIndex + 1), 3000);
                    }
                }
            }, 1000);
        }

        function shoot() {
            const now = Date.now();
            if (now - lastShot < 1000 / weaponStats.fireRate) return;
            
            lastShot = now;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const geometry = new THREE.SphereGeometry(0.1 * weaponStats.bulletSize, 4, 4);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                emissive: 0x444400
            });
            const bullet = new THREE.Mesh(geometry, material);
            
            // –ü–æ–∑–∏—Ü–∏—è –æ—Ç –∏–≥—Ä–æ–∫–∞
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            bullet.position.copy(player.position).add(direction.multiplyScalar(2));
            bullet.position.y += 1;
            
            bullet.userData = {
                type: 'bullet',
                damage: weaponStats.damage,
                speed: weaponStats.bulletSpeed,
                direction: direction.normalize(),
                owner: 'player'
            };
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // –≠—Ñ—Ñ–µ–∫—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞
            const muzzleFlash = new THREE.PointLight(0xffff00, 2, 3);
            muzzleFlash.position.copy(bullet.position);
            scene.add(muzzleFlash);
            
            setTimeout(() => scene.remove(muzzleFlash), 100);
        }

        function applyBuff(buff, isPositive) {
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∞–∫—Ç–∏–≤–Ω—ã–µ –±–∞—Ñ—Ñ—ã
            activeBuffs.push({
                ...buff,
                timestamp: Date.now(),
                isPositive: isPositive
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞
            if (buff.damage) {
                weaponStats.damage *= buff.damage;
            }
            if (buff.speed) {
                playerStats.speed = (playerStats.speed || 1) * buff.speed;
            }
            if (buff.fireRate) {
                weaponStats.fireRate *= buff.fireRate;
            }
            if (buff.health) {
                playerStats.health = Math.min(
                    playerStats.maxHealth,
                    playerStats.health + buff.health
                );
                if (buff.health < 0) {
                    // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞
                    camera.position.x += (Math.random() - 0.5) * 0.5;
                    camera.position.y += (Math.random() - 0.5) * 0.5;
                    setTimeout(() => {
                        camera.position.x = 0;
                        camera.position.y = 5;
                    }, 100);
                }
            }
            if (buff.selfDamage) {
                playerStats.health -= buff.selfDamage;
                if (playerStats.health <= 0) {
                    gameOver();
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            updateUI();
            updateBuffDisplay();
            
            // –ó–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç
            playSound(isPositive ? 'positive' : 'negative');
            
            // –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π –±–∞—Ñ—Ñ
            if (isPositive) {
                playerStats.coins += 5;
            }
        }

        // ==================== –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–û–õ–ö–ù–û–í–ï–ù–ò–ô ====================
        function checkCollisions() {
            // –ü—É–ª–∏ vs –í—Ä–∞–≥–∏
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(
                    bullet.userData.direction.clone().multiplyScalar(bullet.userData.speed)
                );
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã
                if (bullet.position.distanceTo(player.position) > 50) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –≤—Ä–∞–≥–∞–º–∏
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (bullet.position.distanceTo(enemy.position) < 1.5) {
                        // –ü–æ–ø–∞–¥–∞–Ω–∏–µ
                        enemy.userData.health -= bullet.userData.damage;
                        
                        // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
                        const hitEffect = new THREE.PointLight(0xff0000, 3, 2);
                        hitEffect.position.copy(bullet.position);
                        scene.add(hitEffect);
                        setTimeout(() => scene.remove(hitEffect), 200);
                        
                        // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        
                        // –°–º–µ—Ä—Ç—å –≤—Ä–∞–≥–∞
                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            enemiesRemaining--;
                            
                            // –ù–∞–≥—Ä–∞–¥–∞
                            playerStats.coins += enemy.userData.reward;
                            if (enemy.userData.isBoss) {
                                playerStats.gems += 50;
                            }
                            
                            // –≠—Ñ—Ñ–µ–∫—Ç —Å–º–µ—Ä—Ç–∏
                            const explosion = new THREE.PointLight(0xff8800, 5, 5);
                            explosion.position.copy(enemy.position);
                            scene.add(explosion);
                            setTimeout(() => scene.remove(explosion), 500);
                            
                            playSound('explosion');
                        }
                        
                        updateUI();
                        break;
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –≤–æ—Ä–æ—Ç–∞–º–∏
                for (let j = gates.length - 1; j >= 0; j--) {
                    const gate = gates[j];
                    
                    if (bullet.position.distanceTo(gate.position) < 2) {
                        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≤ –∫–∞–∫—É—é —Å—Ç–æ—Ä–æ–Ω—É –ø–æ–ø–∞–ª–∏
                        const gateDirection = new THREE.Vector3()
                            .copy(bullet.position)
                            .sub(gate.position)
                            .normalize();
                        
                        const gateRight = new THREE.Vector3(1, 0, 0).applyQuaternion(gate.quaternion);
                        const isPositiveSide = gateDirection.dot(gateRight) < 0;
                        
                        // –ü–æ–ª—É—á–∞–µ–º –±–∞—Ñ—Ñ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π —Å—Ç–æ—Ä–æ–Ω—ã
                        const side = isPositiveSide ? gate.children[0] : gate.children[1];
                        const buff = side.userData.buff;
                        
                        // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞—Ñ—Ñ
                        applyBuff(buff, side.userData.isPositive);
                        
                        // –≠—Ñ—Ñ–µ–∫—Ç –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
                        const activationEffect = new THREE.PointLight(
                            side.userData.isPositive ? 0x00ff00 : 0xff0000,
                            5, 3
                        );
                        activationEffect.position.copy(gate.position);
                        scene.add(activationEffect);
                        setTimeout(() => scene.remove(activationEffect), 300);
                        
                        // –£–¥–∞–ª–µ–Ω–∏–µ –≤–æ—Ä–æ—Ç
                        scene.remove(gate);
                        gates.splice(j, 1);
                        
                        // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        
                        break;
                    }
                }
            }
            
            // –í—Ä–∞–≥–∏ vs –ò–≥—Ä–æ–∫
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                const direction = new THREE.Vector3()
                    .copy(player.position)
                    .sub(enemy.position)
                    .normalize();
                
                enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
                enemy.lookAt(player.position);
                
                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –∏–≥—Ä–æ–∫–æ–º
                if (enemy.position.distanceTo(player.position) < 1.5) {
                    playerStats.health -= enemy.userData.damage;
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞
                    camera.position.x += (Math.random() - 0.5) * 2;
                    camera.position.y += (Math.random() - 0.5) * 2;
                    setTimeout(() => {
                        camera.position.x = 0;
                        camera.position.y = 5;
                    }, 100);
                    
                    // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –≤—Ä–∞–≥–∞
                    const knockback = direction.clone().multiplyScalar(-2);
                    enemy.position.add(knockback);
                    
                    updateUI();
                    playSound('hit');
                    
                    if (playerStats.health <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï ====================
        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∏—Ç–æ–≤
            if (event.key.length === 1 && event.key.match(/[a-z0-9]/i)) {
                cheatBuffer += event.key.toUpperCase();
                lastCheatTime = Date.now();
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∏—Ç-–∫–æ–¥–æ–≤
                if (cheatBuffer.includes('AMIRHAN')) {
                    playerStats.coins += 10000;
                    playerStats.gems += 100;
                    cheatBuffer = '';
                    updateUI();
                    playSound('cheat');
                    alert('–ß–∏—Ç-–∫–æ–¥ AMIRHAN –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! +10000 –º–æ–Ω–µ—Ç, +100 –∞–ª–º–∞–∑–æ–≤');
                } else if (cheatBuffer.includes('GODMODE')) {
                    playerStats.health = 9999;
                    playerStats.maxHealth = 9999;
                    cheatBuffer = '';
                    updateUI();
                    playSound('cheat');
                    alert('GODMODE –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!');
                }
                
                // –û—á–∏—Å—Ç–∫–∞ –±—É—Ñ–µ—Ä–∞ —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
                setTimeout(() => {
                    if (Date.now() - lastCheatTime > 2000) {
                        cheatBuffer = '';
                    }
                }, 2000);
            }
            
            // –û—Ç–∫—Ä—ã—Ç–∏–µ –º–∞–≥–∞–∑–∏–Ω–∞
            if (event.key === 'm' || event.key === '—å') {
                openShop();
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        function onMouseDown(event) {
            mouse.down = true;
            if (gameActive) {
                shoot();
            }
        }

        function onMouseUp(event) {
            mouse.down = false;
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick(event) {
            if (!gameActive) return;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª–∏–∫–∞ –ø–æ UI —ç–ª–µ–º–µ–Ω—Ç–∞–º
            const rect = renderer.domElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –≤–æ—Ä–æ—Ç–∞–º (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
            const raycaster = new THREE.Raycaster();
            const mouseVector = new THREE.Vector2(
                (x / rect.width) * 2 - 1,
                -(y / rect.height) * 2 + 1
            );
            
            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObjects(gates, true);
            
            if (intersects.length > 0) {
                const gate = intersects[0].object.parent;
                const isPositive = intersects[0].object === gate.children[0];
                const buff = intersects[0].object.userData.buff;
                applyBuff(buff, intersects[0].object.userData.isPositive);
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –≤–æ—Ä–æ—Ç
                const index = gates.indexOf(gate);
                if (index > -1) {
                    scene.remove(gate);
                    gates.splice(index, 1);
                }
            }
        }

        // ==================== UI –ò –ò–ù–¢–ï–†–§–ï–ô–° ====================
        function updateUI() {
            // –ó–¥–æ—Ä–æ–≤—å–µ
            const healthPercent = (playerStats.health / playerStats.maxHealth) * 100;
            document.getElementById('healthFill').style.width = `${healthPercent}%`;
            
            // –†–µ—Å—É—Ä—Å—ã
            document.getElementById('coins').textContent = playerStats.coins;
            document.getElementById('gems').textContent = playerStats.gems;
            document.getElementById('damage').textContent = `x${weaponStats.damage / CONFIG.weapon.baseDamage}`;
            document.getElementById('speed').textContent = `x${playerStats.speed || 1}`;
            document.getElementById('wave').textContent = currentWave + 1;
            document.getElementById('enemies').textContent = enemiesRemaining;
        }

        function updateBuffDisplay() {
            const container = document.getElementById('buffDisplay');
            container.innerHTML = '';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –±–∞—Ñ—Ñ–æ–≤
            const recentBuffs = activeBuffs.slice(-5);
            
            recentBuffs.forEach(buff => {
                const div = document.createElement('div');
                div.className = 'buff-icon';
                div.innerHTML = buff.icon;
                div.title = buff.name + (buff.isPositive ? ' (–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π)' : ' (–û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π)');
                container.appendChild(div);
            });
        }

        function openShop() {
            document.getElementById('shopScreen').style.display = 'block';
            updateShop();
        }

        function closeShop() {
            document.getElementById('shopScreen').style.display = 'none';
        }

        function updateShop() {
            const container = document.getElementById('shopItems');
            container.innerHTML = '';
            
            CONFIG.shop.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                div.innerHTML = `
                    <div>
                        <strong>${item.name}</strong><br>
                        –£—Ä–æ–Ω: ${item.damage || CONFIG.weapon.baseDamage}
                        ${item.fireRate ? `<br>–°–∫–æ—Ä–æ—Å—Ç—Ä–µ–ª—å–Ω–æ—Å—Ç—å: ${item.fireRate}` : ''}
                    </div>
                    <div>
                        ${item.cost > 0 ? `<span class="coins">${item.cost} –º–æ–Ω–µ—Ç</span>` : '–ë–ï–°–ü–õ–ê–¢–ù–û'}
                        ${item.owned ? '<br><small>(–ö—É–ø–ª–µ–Ω–æ)</small>' : ''}
                    </div>
                `;
                
                if (item.cost <= playerStats.coins && !item.owned) {
                    div.style.cursor = 'pointer';
                    div.onclick = () => purchaseWeapon(index);
                } else if (item.owned) {
                    div.style.cursor = 'pointer';
                    div.onclick = () => equipWeapon(index);
                } else {
                    div.style.opacity = '0.5';
                }
                
                container.appendChild(div);
            });
        }

        function purchaseWeapon(index) {
            const item = CONFIG.shop[index];
            
            if (playerStats.coins >= item.cost && !item.owned) {
                playerStats.coins -= item.cost;
                CONFIG.shop[index].owned = true;
                updateUI();
                updateShop();
                equipWeapon(index);
                playSound('purchase');
            }
        }

        function equipWeapon(index) {
            const item = CONFIG.shop[index];
            weaponStats.damage = item.damage;
            if (item.fireRate) {
                weaponStats.fireRate = item.fireRate;
            }
            updateUI();
            playSound('equip');
        }

        // ==================== –ò–ì–†–û–í–´–ï –°–û–°–¢–û–Ø–ù–ò–Ø ====================
        function gameOver() {
            gameActive = false;
            document.getElementById('finalWave').textContent = currentWave + 1;
            document.getElementById('gameOverScreen').style.display = 'flex';
            playSound('gameOver');
        }

        function victory() {
            gameActive = false;
            document.getElementById('victoryScreen').style.display = 'flex';
            playSound('victory');
        }

        function restartGame() {
            // –°–±—Ä–æ—Å –∏–≥—Ä—ã
            scene.remove(player);
            enemies.forEach(e => scene.remove(e));
            bullets.forEach(b => scene.remove(b));
            gates.forEach(g => scene.remove(g));
            
            enemies = [];
            bullets = [];
            gates = [];
            activeBuffs = [];
            
            playerStats = { ...CONFIG.player };
            weaponStats = { ...CONFIG.weapon };
            currentWave = 0;
            enemiesRemaining = 0;
            gameActive = true;
            
            createPlayer();
            startWave(0);
            
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            closeShop();
            
            updateUI();
            updateBuffDisplay();
        }

        // ==================== –ê–£–î–ò–û ====================
        function playSound(type) {
            // –ü—Ä–æ—Å—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ –∑–≤—É–∫–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'shoot':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                    case 'hit':
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'explosion':
                        oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                    case 'positive':
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'negative':
                        oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime); // G4
                        oscillator.frequency.setValueAtTime(329.63, audioContext.currentTime + 0.1); // E4
                        oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime + 0.2); // C4
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'cheat':
                        for(let i = 0; i < 5; i++) {
                            oscillator.frequency.setValueAtTime(440 * (i+1), audioContext.currentTime + i * 0.05);
                        }
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.25);
                        break;
                }
            } catch(e) {
                console.log("Audio not supported");
            }
        }

        // ==================== –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ====================
        function updateGame() {
            if (!gameActive) return;
            
            gameTime += 0.016; // –ø—Ä–∏–º–µ—Ä–Ω–æ 60 FPS
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–º
            const moveSpeed = CONFIG.player.speed * (playerStats.speed || 1);
            const rotationSpeed = CONFIG.player.rotationSpeed;
            
            if (keys['w'] || keys['—Ü']) {
                player.position.x -= Math.sin(player.rotation.y) * moveSpeed;
                player.position.z -= Math.cos(player.rotation.y) * moveSpeed;
            }
            if (keys['s'] || keys['—ã']) {
                player.position.x += Math.sin(player.rotation.y) * moveSpeed;
                player.position.z += Math.cos(player.rotation.y) * moveSpeed;
            }
            if (keys['a'] || keys['—Ñ']) {
                player.position.x -= Math.cos(player.rotation.y) * moveSpeed;
                player.position.z += Math.sin(player.rotation.y) * moveSpeed;
            }
            if (keys['d'] || keys['–≤']) {
                player.position.x += Math.cos(player.rotation.y) * moveSpeed;
                player.position.z -= Math.sin(player.rotation.y) * moveSpeed;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –º—ã—à—å—é
            if (mouse.down) {
                player.rotation.y -= mouse.x * rotationSpeed * 10;
            }
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∞—Ä–µ–Ω—ã
            player.position.x = Math.max(-45, Math.min(45, player.position.x));
            player.position.z = Math.max(-45, Math.min(45, player.position.z));
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–µ
            if (mouse.down && gameTime - lastShot > 1 / weaponStats.fireRate) {
                shoot();
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 10;
            camera.position.y = player.position.y + 5;
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            checkCollisions();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            enemies.forEach(enemy => {
                if (enemy.userData.isBoss) {
                    enemy.scale.x = 1 + Math.sin(gameTime) * 0.1;
                    enemy.scale.y = 1 + Math.cos(gameTime) * 0.1;
                    enemy.scale.z = 1 + Math.sin(gameTime * 0.5) * 0.1;
                }
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞—Ç
            gates.forEach(gate => {
                gate.rotation.y += 0.01;
                
                // –ü–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ
                const lifetime = Date.now() - gate.userData.spawnTime;
                if (lifetime > CONFIG.gates.lifetime - 2000) {
                    const alpha = 1 - (lifetime - (CONFIG.gates.lifetime - 2000)) / 2000;
                    gate.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = alpha;
                        }
                    });
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            updateGame();
            renderer.render(scene, camera);
            
            // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            document.getElementById('debugInfo').innerHTML = `
                FPS: ${Math.round(1000 / (Date.now() - (window.lastFrameTime || Date.now())))}
                –û–±—ä–µ–∫—Ç–æ–≤: ${scene.children.length}
                –ë–∞—Ñ—Ñ–æ–≤: ${activeBuffs.length}
            `;
            window.lastFrameTime = Date.now();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== –ó–ê–ü–£–°–ö –ò–ì–†–´ ====================
        window.onload = init;
    </script>
</body>
</html>
